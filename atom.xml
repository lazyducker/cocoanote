<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>2017 My Best Wishes</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.todolist.win/"/>
  <updated>2017-06-11T09:02:10.000Z</updated>
  <id>http://blog.todolist.win/</id>
  
  <author>
    <name>Lazyducker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一些关于架构的</title>
    <link href="http://blog.todolist.win/2017/06/10/20170610-note-architecture/"/>
    <id>http://blog.todolist.win/2017/06/10/20170610-note-architecture/</id>
    <published>2017-06-10T14:58:39.000Z</published>
    <updated>2017-06-11T09:02:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="guan-yu-jia-gou-zhuan"><a href="guan-yu-jia-gou-zhuan" class="header-anchor">"#"</a><a href="#关于架构-转" class="headerlink" title="关于架构[转]"></a>关于架构[转]</h3><hr>
<p><a href="http://www.infoq.com/cn/articles/every-architect-should-study-conway-law/" target="_blank" rel="external">原文地址</a> </p>
<h4 id="jia-gou-de-ding-yi-yu-li-jie"><a href="jia-gou-de-ding-yi-yu-li-jie" class="header-anchor">"#"</a><a href="#架构的定义与理解" class="headerlink" title="架构的定义与理解"></a>架构的定义与理解</h4><p>一. 架构系统前, 架构师的首要任务是 尽最快可能找到利益相关者: <code>业务方</code>, <code>产品经理</code>, <code>客户/用户</code>, <code>开发经理</code>, <code>工程师</code>, <code>项目经理</code>,  <code>测试人员</code> , <code>运维人员</code> ,<code>产品运营人员</code> 等等都可能是利益相关者, 架构师要充分和利益相关者沟通, 深入了解他们的关注点和痛点, 并找出并构架出这些关注点的解决方案.</p>
<p>二. 利益相关者的关注点是有可能冲突的, 比如: </p>
<blockquote>
<ol>
<li>管理者(可管理性) VS 技术方 (性能)</li>
<li>业务方(多快好省) VS 技术方(可靠稳定)   </li>
</ol>
</blockquote>
<p>等等这些需要架构师去灵活的平衡, 如何平衡体现了架构师的水平</p>
<p>三. 架构主要关注非功能性需求 </p>
<blockquote>
<ol>
<li>易于分解(保持独立性)</li>
<li>易于理解</li>
<li>易于扩展</li>
<li>易于变更</li>
<li>易于替换</li>
<li>易于部署</li>
<li>易于伸缩(伸缩性)</li>
<li>易于恢复(还原能力)</li>
<li>易于连接(统一接口)</li>
<li>易于交付(成本&amp;效率)</li>
</ol>
</blockquote>
<p>四. 架构的目的用于管理复杂性、易变性和不确定性， 确保长期演变的架构部分的变化不会对架构的其他部分产生不必要的负面影响. 这样可以确保业务和开发的敏捷， 让应用的易变部分能够频繁的变化而不影响（或者影响更少）应用其他部分  </p>
<p>五. 国内企业IT的现状是：无数高耦合的遗留系统，不良的架构设计导致限制了企业的业务，升级替换的成本巨大，<u>所以此时架构的关注点由性能、高可用转变为更加关注可维护性、可扩展性、成本</u>。 所以企业创业之初选择好的架构师或技术负责人非常重要. </p>
<a id="more"></a> 
<h4 id="jia-gou-de-die-dai-he-yan-hua-xing"><a href="jia-gou-de-die-dai-he-yan-hua-xing" class="header-anchor">"#"</a><a href="#架构的迭代和演化性" class="headerlink" title="架构的迭代和演化性"></a>架构的迭代和演化性</h4><h5 id="yi-rup-de-san-ge-te-dian"><a href="yi-rup-de-san-ge-te-dian" class="header-anchor">"#"</a><a href="#一-RUP的三个特点" class="headerlink" title="一. RUP的三个特点"></a>一. RUP的三个特点</h5><blockquote>
<ol>
<li>用例和风险驱动(use case and risk driven)</li>
<li>架构中心(Architecture centric)</li>
<li>迭代和增量(Iterative and incremental) </li>
</ol>
</blockquote>
<p>RUP提倡以架构和风险驱动, 项目一开始要做到 端到端的原型(prototype) ； 通过压力测试验证框架的可行性 ，在原型的基础上进行持续迭代和增量开发， 开发-&gt;测试-&gt;调整架构-&gt;开发</p>
<p><img src="/2017/06/10/20170610-note-architecture/114.jpg" alt=""></p>
<p>从上面的图可以看出：<code>架构是一个不断演进和迭代的过程</code> 而不是一蹴而就 ，一来就求大而全（架构师的完美主义不一定是好事），所以架构师要尽量写代码，做测试，否则纸上谈兵然后丢给开发团队是很不负责任的做法，容易造成产品不能满足最终用户需求。</p>
<h5 id="er-zui-xiao-ke-yong-chan-pin"><a href="er-zui-xiao-ke-yong-chan-pin" class="header-anchor">"#"</a><a href="#二-最小可用产品" class="headerlink" title="二. 最小可用产品"></a>二. 最小可用产品</h5><p>最小可用产品（Minimum Viable Product， MVP）理念, 即迅速做出最小可用的产品，丢给客户试用，快速获取用户反馈，在此基础上不断进行产品架构的迭代和演化升级: </p>
<p><img src="/2017/06/10/20170610-note-architecture/115.jpg" alt=""></p>
<p>如上图就是描述了架构师应该迅速做出最小可用产品，从而使得用户尽快试用产品并在此基础上快速更新升级，否则做出最终的产品无法满足客户需求而导致了成本和风险的提高。</p>
<p><img src="/2017/06/10/20170610-note-architecture/116.jpg" alt=""></p>
<p>上图反应了过度工程(Over Engineering)的问题, 其实就是产品架构和用户之间没有形成有效的反馈闭环</p>
<blockquote class="blockquote-center"><br><br><strong> 注意 </strong> ，在系统真正地投入生产使用之前，再好的架构都只是假设，产品越晚被使用者使用，失败的成本和风险就越高，而小步行进，通过 <strong><strong> MVP </strong></strong> 快速实验，获取客户反馈，迭代演化产品，能有效地减少失败的成本和风险。<br><br></blockquote>





<h5 id="can-kao-zi-liao"><a href="can-kao-zi-liao" class="header-anchor">"#"</a><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ul>
<li><a href="http://itrevolution.com/the-three-ways-principles-underpinning-devops/" target="_blank" rel="external">THE THREE WAYS: THE PRINCIPLES UNDERPINNING DEVOPS</a></li>
<li><a href="http://baike.baidu.com/link?url=PcIm9RTOWnAd0rqN7f5rrlbt9QmjWgPctJ5i4K5ObjPqD7KtOMIQRBiUVMZ5YpuQ_uymtAdsT-n-0hB4sCVyNK" target="_blank" rel="external">统一软件开发过程</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关于架构-转&quot;&gt;&lt;a href=&quot;#关于架构-转&quot; class=&quot;headerlink&quot; title=&quot;关于架构[转]&quot;&gt;&lt;/a&gt;关于架构[转]&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/every-architect-should-study-conway-law/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt; &lt;/p&gt;
&lt;h4 id=&quot;架构的定义与理解&quot;&gt;&lt;a href=&quot;#架构的定义与理解&quot; class=&quot;headerlink&quot; title=&quot;架构的定义与理解&quot;&gt;&lt;/a&gt;架构的定义与理解&lt;/h4&gt;&lt;p&gt;一. 架构系统前, 架构师的首要任务是 尽最快可能找到利益相关者: &lt;code&gt;业务方&lt;/code&gt;, &lt;code&gt;产品经理&lt;/code&gt;, &lt;code&gt;客户/用户&lt;/code&gt;, &lt;code&gt;开发经理&lt;/code&gt;, &lt;code&gt;工程师&lt;/code&gt;, &lt;code&gt;项目经理&lt;/code&gt;,  &lt;code&gt;测试人员&lt;/code&gt; , &lt;code&gt;运维人员&lt;/code&gt; ,&lt;code&gt;产品运营人员&lt;/code&gt; 等等都可能是利益相关者, 架构师要充分和利益相关者沟通, 深入了解他们的关注点和痛点, 并找出并构架出这些关注点的解决方案.&lt;/p&gt;
&lt;p&gt;二. 利益相关者的关注点是有可能冲突的, 比如: &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;管理者(可管理性) VS 技术方 (性能)&lt;/li&gt;
&lt;li&gt;业务方(多快好省) VS 技术方(可靠稳定)   &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;等等这些需要架构师去灵活的平衡, 如何平衡体现了架构师的水平&lt;/p&gt;
&lt;p&gt;三. 架构主要关注非功能性需求 &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;易于分解(保持独立性)&lt;/li&gt;
&lt;li&gt;易于理解&lt;/li&gt;
&lt;li&gt;易于扩展&lt;/li&gt;
&lt;li&gt;易于变更&lt;/li&gt;
&lt;li&gt;易于替换&lt;/li&gt;
&lt;li&gt;易于部署&lt;/li&gt;
&lt;li&gt;易于伸缩(伸缩性)&lt;/li&gt;
&lt;li&gt;易于恢复(还原能力)&lt;/li&gt;
&lt;li&gt;易于连接(统一接口)&lt;/li&gt;
&lt;li&gt;易于交付(成本&amp;amp;效率)&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;四. 架构的目的用于管理复杂性、易变性和不确定性， 确保长期演变的架构部分的变化不会对架构的其他部分产生不必要的负面影响. 这样可以确保业务和开发的敏捷， 让应用的易变部分能够频繁的变化而不影响（或者影响更少）应用其他部分  &lt;/p&gt;
&lt;p&gt;五. 国内企业IT的现状是：无数高耦合的遗留系统，不良的架构设计导致限制了企业的业务，升级替换的成本巨大，&lt;u&gt;所以此时架构的关注点由性能、高可用转变为更加关注可维护性、可扩展性、成本&lt;/u&gt;。 所以企业创业之初选择好的架构师或技术负责人非常重要. &lt;/p&gt;
    
    </summary>
    
      <category term="Home" scheme="http://blog.todolist.win/categories/Home/"/>
    
    
      <category term="日记" scheme="http://blog.todolist.win/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>札记</title>
    <link href="http://blog.todolist.win/2017/06/09/%E6%9C%AD%E8%AE%B0/"/>
    <id>http://blog.todolist.win/2017/06/09/札记/</id>
    <published>2017-06-09T06:21:11.000Z</published>
    <updated>2017-06-09T06:21:11.000Z</updated>
    
    <summary type="html">
    
      一些札记
    
    </summary>
    
      <category term="Home" scheme="http://blog.todolist.win/categories/Home/"/>
    
    
      <category term="日记" scheme="http://blog.todolist.win/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM性能分析之Dump文件生成与分析</title>
    <link href="http://blog.todolist.win/2017/01/17/JVM%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8BDump%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>http://blog.todolist.win/2017/01/17/JVM性能分析之Dump文件生成与分析/</id>
    <published>2017-01-17T06:56:54.000Z</published>
    <updated>2017-01-17T07:18:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="dump-ji-ben-gai-nian"><a href="dump-ji-ben-gai-nian" class="header-anchor">"#"</a><a href="#Dump基本概念" class="headerlink" title="Dump基本概念"></a>Dump基本概念</h3><p>常用dump文件分为: heap dump和 thread dump两种，heap dump主要记录了内存信息，thread dump 记录了CPU信息 </p>
<p><strong><code>heap dump</code></strong> 文件是一个二进制文件，它保存了某一时刻JVM堆中对象使用情况。HeapDump文件是指定时刻的Java堆栈的快照，是一种镜像文件。Heap Analyzer工具通过分析HeapDump文件，哪些对象占用了太多的堆栈空间，来发现导致内存泄露或者可能引起内存泄露的对象。</p>
<p><strong><code>thread dump</code></strong> 文件主要保存的是java应用中各线程在某一时刻的运行的位置，即执行到哪一个类的哪一个方法哪一个行上。thread dump是一个文本文件，打开后可以看到每一个线程的执行栈，以stacktrace的方式显示。通过对thread dump的分析可以得到应用是否“卡”在某一点上，即在某一点运行的时间太长，如数据库查询，长期得不到响应，最终导致系统崩溃。单个的thread dump文件一般来说是没有什么用处的，因为它只是记录了某一个绝对时间点的情况。比较有用的是，线程在一个时间段内的执行情况。<br>两个thread dump文件在分析时特别有效，困为它可以看出在先后两个时间点上，线程执行的位置，如果发现先后两组数据中同一线程都执行在同一位置，则说明此处可能有问题，因为程序运行是极快的，如果两次均在某一点上，说明这一点的耗时是很大的。通过对这两个文件进行分析，查出原因，进而解决问题。</p>
<p>这两个文件可以使用jdk自带的工具生成. . </p>
<h4 id="heap-dump"><a href="heap-dump" class="header-anchor">"#"</a><a href="#heap-dump" class="headerlink" title="heap dump"></a>heap dump</h4><p>使用 jdk的jmap命令<br><code>jmap -dump:format=b,file=heap.hprof 2576</code> </p>
<p>如果我们只需要将dump中存活的对象导出，那么可以使用:live参数 </p>
<p><code>jmap -dump:live,format=b,file=heapLive.hprof 2576</code>  </p>
<h4 id="thread-dump"><a href="thread-dump" class="header-anchor">"#"</a><a href="#thread-dump" class="headerlink" title="thread dump"></a>thread dump</h4><p>使用 <code>jstack 2576 &gt; thread.txt</code>  </p>
<p>有了dump文件后，再结合使用性能分析工具就可以获取并分析文件中的系统信息  </p>
<h3 id="shi-yong-gong-ju-fen-xi-heap-dump-wen-jian"><a href="shi-yong-gong-ju-fen-xi-heap-dump-wen-jian" class="header-anchor">"#"</a><a href="#使用工具分析heap-dump文件" class="headerlink" title="使用工具分析heap dump文件"></a>使用工具分析heap dump文件</h3><h4 id="jhat-ming-ling"><a href="jhat-ming-ling" class="header-anchor">"#"</a><a href="#jhat命令" class="headerlink" title="jhat命令"></a>jhat命令</h4><h4 id="eclipse-mat"><a href="eclipse-mat" class="header-anchor">"#"</a><a href="#eclipse-MAT" class="headerlink" title="eclipse MAT"></a>eclipse MAT</h4>]]></content>
    
    <summary type="html">
    
      dump文件记录了JVM在运行期间的内存占用、线程执行等情况，利用dump文件结合eclipse MAT工具可以有效的排查项目运行中的性能及内存等问题
    
    </summary>
    
    
      <category term="jvm" scheme="http://blog.todolist.win/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>使用Git管理项目</title>
    <link href="http://blog.todolist.win/2017/01/17/%E4%BD%BF%E7%94%A8Git%E7%AE%A1%E7%90%86%E9%A1%B9/"/>
    <id>http://blog.todolist.win/2017/01/17/使用Git管理项/</id>
    <published>2017-01-17T03:25:16.000Z</published>
    <updated>2017-01-17T03:44:34.000Z</updated>
    
    <summary type="html">
    
      作为源码版本控制技术栈的一部分，Git是一个重要的工具，由于工作上的原因一直都没有使用到Git,但是对于热衷各种开源项目的我，已经看到了越来越多的项目使用了Git，似乎使用Git已经是一个标准配套
    
    </summary>
    
      <category term="Git" scheme="http://blog.todolist.win/categories/Git/"/>
    
    
      <category term="Git" scheme="http://blog.todolist.win/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>OpenSource</title>
    <link href="http://blog.todolist.win/2017/01/10/OpenSource/"/>
    <id>http://blog.todolist.win/2017/01/10/OpenSource/</id>
    <published>2017-01-10T01:36:12.000Z</published>
    <updated>2017-01-10T02:42:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="zipkin"><a href="zipkin" class="header-anchor">"#"</a><a href="#zipkin" class="headerlink" title="zipkin"></a>zipkin</h3><p>用于分布式微服务系统的服务追踪 </p>
<blockquote class="blockquote-center"><br>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in microservice architectures<br></blockquote>

<p><a href="https://github.com/openzipkin/zipkin" target="_blank" rel="external">https://github.com/openzipkin/zipkin</a></p>
]]></content>
    
    <summary type="html">
    
      从GitHub上收集一些有意思的开源项目，
    
    </summary>
    
      <category term="OpenSource" scheme="http://blog.todolist.win/categories/OpenSource/"/>
    
    
      <category term="Github" scheme="http://blog.todolist.win/tags/Github/"/>
    
      <category term="OpenSource" scheme="http://blog.todolist.win/tags/OpenSource/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 集成目录插件</title>
    <link href="http://blog.todolist.win/2017/01/09/Hexo-%E9%9B%86%E6%88%90%E7%9B%AE%E5%BD%95%E6%8F%92%E4%BB%B6/"/>
    <id>http://blog.todolist.win/2017/01/09/Hexo-集成目录插件/</id>
    <published>2017-01-09T12:37:52.000Z</published>
    <updated>2017-01-10T02:13:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>hexo提供了丰富的<a href="https://hexo.io/plugins/" target="_blank" rel="external">插件列表</a></p>
<p>好的博客文章应该具备清晰的层级结构，hexo默认没有不支持目录的生成（或者支持，我没有找到方法？，总之我找到一个新的通过集成hexo插件的方式）,今天主要是集成一下hexo主题对应的目录插件</p>
<p>我们选择<a href="https://github.com/bubkoo/hexo-toc" target="_blank" rel="external">hexo-toc</a></p>
<a id="more"></a>
<h3 id="an-zhuang-hexo-toc"><a href="an-zhuang-hexo-toc" class="header-anchor">"#"</a><a href="#安装hexo-toc" class="headerlink" title="安装hexo-toc"></a>安装hexo-toc</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnpm install hexo-toc --save</div></pre></td></tr></table></figure>
<p>安装完成后，在站点配置文件(_config.xml)文件中添加如下配置选项</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attr">toc:</span></div><div class="line"><span class="attr">  maxdepth:</span> <span class="number">3</span></div><div class="line"><span class="attr">  class:</span> <span class="string">toc</span></div><div class="line"><span class="attr">  slugify:</span> <span class="string">transliteration</span></div><div class="line"><span class="attr">  anchor:</span></div><div class="line"><span class="attr">    position:</span> <span class="string">after</span></div><div class="line"><span class="attr">    symbol:</span> <span class="string">'#'</span></div><div class="line"><span class="attr">    style:</span> <span class="string">header-anchor</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>maxdepth</code>表示支持的层级深度，即 <code>symbol</code>指定的分隔符的长度</p>
<p><code>class</code> 表示toc生成的样式Class</p>
<p><code>slugify</code>: Choose which slugify function you want to use. Currently support <a href="https://github.com/jeremys/uslug" target="_blank" rel="external">uslug</a> (<em>Default</em>) and <a href="https://github.com/andyhu/node-transliteration" target="_blank" rel="external">transliteration</a>.(slugify功能目前不知道什么用途，暂时用的)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      好的博客文章应该具备清晰的层级结构, 一眼就能看出作者的思路脉络, 今天就来看看hexo如何集成toc目录插件
    
    </summary>
    
      <category term="hexo" scheme="http://blog.todolist.win/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://blog.todolist.win/tags/hexo/"/>
    
      <category term="Github" scheme="http://blog.todolist.win/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 安装笔记</title>
    <link href="http://blog.todolist.win/2017/01/09/Hexo-%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.todolist.win/2017/01/09/Hexo-安装笔记/</id>
    <published>2017-01-09T06:32:33.000Z</published>
    <updated>2017-06-08T11:47:57.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc">

<!-- toc -->
<ul>
<li><a href="#hexo-an-zhuang-bi-ji">Hexo 安装笔记</a><ul>
<li><a href="#1-jian-yao-shuo-ming">1.简要说明</a></li>
<li><a href="#2-hexo-chang-yong-ming-ling">2. Hexo常用命令</a></li>
<li><a href="#ru-he-bu-shu-dao-github-shang">如何部署到GitHub上</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>

<h3 id="hexo-an-zhuang-bi-ji"><a href="hexo-an-zhuang-bi-ji" class="header-anchor">"#"</a><a href="#Hexo-安装笔记" class="headerlink" title="Hexo 安装笔记"></a>Hexo 安装笔记</h3><h4 id="1-jian-yao-shuo-ming"><a href="1-jian-yao-shuo-ming" class="header-anchor">"#"</a><a href="#1-简要说明" class="headerlink" title="1.简要说明"></a>1.简要说明</h4><p><a href="https://hexo.io/" target="_blank" rel="external">https://hexo.io/</a><br>使用npm安装命令如下</p>
<blockquote>
<p>npm install hexo-cli -g<br>hexo init blog<br>cd blog<br>npm install<br>hexo server</p>
</blockquote>
<p>npm在国内访问较慢，可以使用阿里的镜像地址，使用如下命令切换<br><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code><br>后续命令npm命令使用 cnpm代替</p>
<h4 id="2-hexo-chang-yong-ming-ling"><a href="2-hexo-chang-yong-ming-ling" class="header-anchor">"#"</a><a href="#2-Hexo常用命令" class="headerlink" title="2. Hexo常用命令"></a>2. Hexo常用命令</h4><h5 id="init"><a href="init" class="header-anchor">"#"</a><a href="#init" class="headerlink" title="init"></a>init</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> hexo init [folder]</div></pre></td></tr></table></figure>
<p>初始化一个新的网站目录,如果不指定则默认使用当前目录</p>
<h5 id="new"><a href="new" class="header-anchor">"#"</a><a href="#new" class="headerlink" title="new"></a>new</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> hexo new [layout] &lt;title&gt;</div></pre></td></tr></table></figure>
<p>创建一篇新的文章，使用layout指定的布局方式，如果layout不指定，则使用<code>_config.yml</code> 中的<code>default_layout</code>  指定的值, title为文章标题，如果title中含有空格，需要使用双引号包含整个title</p>
<h5 id="generate"><a href="generate" class="header-anchor">"#"</a><a href="#generate" class="headerlink" title="generate"></a>generate</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>创建静态文件,有如下参数</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-w, –watch</td>
<td>Watch file changes</td>
</tr>
<tr>
<td>-d, –deploy</td>
<td>Deploy after generation finishes</td>
</tr>
</tbody>
</table>
<h5 id="publish"><a href="publish" class="header-anchor">"#"</a><a href="#publish" class="headerlink" title="publish"></a>publish</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> hexo publish [layout] &lt;filename&gt;</div></pre></td></tr></table></figure>
<p>发布一条草稿</p>
<h5 id="server"><a href="server" class="header-anchor">"#"</a><a href="#server" class="headerlink" title="server"></a>server</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> hexo server</div></pre></td></tr></table></figure>
<p>启动本地服务: 默认访问地址是 <code>http://localhost:4000/</code></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p, –port</td>
<td>Override default port</td>
</tr>
<tr>
<td>-s, –static</td>
<td>Only serve static files</td>
</tr>
<tr>
<td>-l, –log</td>
<td>Enable logger. Override logger format.</td>
</tr>
</tbody>
</table>
<h5 id="deploy"><a href="deploy" class="header-anchor">"#"</a><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> hexo deploy</div></pre></td></tr></table></figure>
<p>部署网站</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-g, –generate</td>
<td>在部署前创建</td>
</tr>
</tbody>
</table>
<h5 id="render"><a href="render" class="header-anchor">"#"</a><a href="#render" class="headerlink" title="render"></a>render</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> hexo render &lt;file1&gt; [file2] ...</div></pre></td></tr></table></figure>
<p>渲染文件</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-o, –output</td>
<td>输出到指定目录</td>
</tr>
</tbody>
</table>
<h5 id="migrate"><a href="migrate" class="header-anchor">"#"</a><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> hexo migrate &lt;type&gt;</div></pre></td></tr></table></figure>
<p>从其他博客系统迁移内容</p>
<h5 id="clean"><a href="clean" class="header-anchor">"#"</a><a href="#clean" class="headerlink" title="clean"></a>clean</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> hexo clean</div></pre></td></tr></table></figure>
<p>清理缓存文件<code>(db.json)</code> 然后重新创建文件目录 <code>(public)</code>.</p>
<h5 id="list"><a href="list" class="header-anchor">"#"</a><a href="#list" class="headerlink" title="list"></a>list</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> hexo list &lt;type&gt;</div></pre></td></tr></table></figure>
<p>列举网站(博客)信息List the information of the site.<br>type可选的值列表 : page, post, route, tag, category</p>
<h4 id="ru-he-bu-shu-dao-github-shang"><a href="ru-he-bu-shu-dao-github-shang" class="header-anchor">"#"</a><a href="#如何部署到GitHub上" class="headerlink" title="如何部署到GitHub上"></a>如何部署到GitHub上</h4><p>关于如何开启GitHub的Pages服务,网上的资料太多,而且大同小异, 这里就不在重复.</p>
<blockquote>
<p>编辑完文章后 使用 <code>hexo d -g</code> 即可部署到GitHub上</p>
</blockquote>
<p>未完待续……</p>
<hr>
<p>参考引用:   </p>
<ul>
<li><a href="http://blog.csdn.net/jzooo/article/details/46781805" target="_blank" rel="external">http://blog.csdn.net/jzooo/article/details/46781805</a>  </li>
<li><a href="http://baixin.io/2016/06/HEXO_Advanced/" target="_blank" rel="external">http://baixin.io/2016/06/HEXO_Advanced/</a>  </li>
<li><a href="http://www.jianshu.com/p/465830080ea9" target="_blank" rel="external">http://www.jianshu.com/p/465830080ea9</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      终于开始了2017年的第一篇博客了，想想没说好说的，要不就从搭建一个github网站开始吧，这里我用的是Hexo静态博客，使用Github的Pages服务并绑定个人域名http://blog.todolist.win
    
    </summary>
    
      <category term="hexo" scheme="http://blog.todolist.win/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://blog.todolist.win/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Vue实例</title>
    <link href="http://blog.todolist.win/2017/01/08/Vue%E5%AE%9E%E4%BE%8B/"/>
    <id>http://blog.todolist.win/2017/01/08/Vue实例/</id>
    <published>2017-01-08T07:40:11.000Z</published>
    <updated>2017-06-09T06:47:35.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="vue-shi-li-sheng-ming-zhou-qi"><a href="vue-shi-li-sheng-ming-zhou-qi" class="header-anchor">"#"</a><a href="#Vue实例生命周期" class="headerlink" title="Vue实例生命周期"></a>Vue实例生命周期</h4><p>每个Vue实例被创建之前要经过一系列的初始化过程，</p>
<p>实例需要配置:</p>
<blockquote>
<p>1.配置数据观测(Data Observer)<br>2.编译模板<br>3.挂载实例到DOM<br>4.数据变化时更新DOM</p>
</blockquote>
<p>在上述过程中，实例会调用生命周期的一些钩子方法,可以执行自定义逻辑：</p>
<blockquote>
<p>created: 钩子方法, 在实例被创建之后被调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line"><span class="attr">data</span>: &#123;</div><div class="line"><span class="attr">a</span>: <span class="number">1</span></div><div class="line">&#125;,</div><div class="line"><span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">//`this` 指向vm实例</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'a is: '</span> + <span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
</blockquote>
<p>还有其他钩子，例如 <code>mounted</code>, <code>updated</code>, <code>destroyed</code>, 这些钩子可以再实例生命周期的不同阶段调用，<code>this</code>关键字指向的是vue的实例.<br>vue中无控制器的概念，需要自定义逻辑，可以分别在这些不同的钩子方法中实现</p>
<p><img src="/2017/01/08/Vue实例/lifecycle.png" alt="生命周期"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;vue-shi-li-sheng-ming-zhou-qi&quot;&gt;&lt;a href=&quot;vue-shi-li-sheng-ming-zhou-qi&quot; class=&quot;header-anchor&quot;&gt;&quot;#&quot;&lt;/a&gt;&lt;a href=&quot;#Vue实例生命周期&quot; class=&quot;head
    
    </summary>
    
    
  </entry>
  
</feed>
