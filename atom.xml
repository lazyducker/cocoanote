<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>2017 My Best Wishes</title>
  
  <subtitle>新的开始</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.todolist.win/"/>
  <updated>2018-06-11T09:18:02.342Z</updated>
  <id>http://blog.todolist.win/</id>
  
  <author>
    <name>Lazyducker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java CountDownLatch Example - Multithreading and Concurrency Tutorial</title>
    <link href="http://blog.todolist.win/2018/01/09/Java%20CountDownLatch%E7%A4%BA%E4%BE%8B%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    <id>http://blog.todolist.win/2018/01/09/Java CountDownLatch示例 多线程和并发指南/</id>
    <published>2018-01-09T06:32:33.000Z</published>
    <updated>2018-06-11T09:18:02.342Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#countdownlatch-important-points">CountDownLatch - Important Points</a></li></ul><!-- tocstop --><p></div><br>Java CountDownLatch Example - Multithreading and Concurrency Tutorial</p><p>The <code>CountDownLatch</code> is an important concurrency utility class which was added in JDK 1.5 but unfortunately, many Java developers still struggle to understand and use this powerful tool. </p><p>You can use <code>CountDownLatch</code> if you are spawning multiple threads to do different jobs and want to know when exactly all tasks are finished so that you can move to next stage. In other words, you can block a thread until other threads complete their task. </p><p>One of the good examples where you can use <code>CountDownLatch</code> is an application which downloads data from a database or another application. For example, we are creating a Java program to download all Udemy courses. </p><p>Since Udemy has thousands of courses, you create different threads to download different categories e.g. technology, development etc.</p><p>Your application can only be started once all data is loaded and to know the status of your loading progress you can create a <code>CountDownLatch</code>.</p><p>Suppose, you have spawned 5 threads to load five different categories of data then you can create a <code>CountDownLatch</code> with 5 counts and then bring down the count by 1 when loading of one category is finished. You can do this by calling the countDown() method.</p><p>Since different thread will take different time, your main thread can wait until all threads have completed and it can do by checking the remaining count by calling <code>getCount()</code> method or just calling the <code>CountDownLatch.await()</code>method, which causes current thread to wait until the latch has counted down to zero or the thread is interrupted.</p><p>Once the count becomes zero, it can announce that application is started and ready to accept client connections.</p><p>Here is a simplified version of Java Code for above scenario which demonstrates downloading data in multiple threads and using <code>CountDownLatch</code> to check completion.</p><p><strong>CountDownLatch Example in Java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vehicle.test.moudle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * * A simple example of CountDownLatch in Java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch loadingLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">Thread pythonCourseLoader = <span class="keyword">new</span> Thread(<span class="string">"PythonCourseLoader"</span>) &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Loading all Python courses from Udemy.."</span>);</span><br><span class="line"><span class="comment">// loading Python courses ....</span></span><br><span class="line"><span class="comment">// loading completed, time to count down</span></span><br><span class="line">System.out.println(<span class="string">"loading completed for Python courses"</span>);</span><br><span class="line">loadingLatch.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Thread javaCourseLoader = <span class="keyword">new</span> Thread(<span class="string">"JavaCourseLoader"</span>) &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Loading all Java courses from Udemy .."</span>);</span><br><span class="line"><span class="comment">// loading Java courses ....</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"loading completed for Java courses"</span>);</span><br><span class="line">loadingLatch.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Thread developmentCourseLoader = <span class="keyword">new</span> Thread(<span class="string">"developmentCourseLoader"</span>) &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Loading all Develoment courses from Udemy .."</span>);</span><br><span class="line"><span class="comment">// loading development courses ....</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"loading completed for development courses"</span>);</span><br><span class="line">loadingLatch.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">pythonCourseLoader.start();</span><br><span class="line">javaCourseLoader.start();</span><br><span class="line">developmentCourseLoader.start();</span><br><span class="line"><span class="keyword">while</span> (loadingLatch.getCount() != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// wait</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// loadingLatch.await();</span></span><br><span class="line">System.out.println(<span class="string">"all done."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Output: </span></span><br><span class="line"><span class="comment">Loading all Python courses from Udemy.. </span></span><br><span class="line"><span class="comment">loading completed for Python courses </span></span><br><span class="line"><span class="comment">Loading all Development courses from Udemy .. </span></span><br><span class="line"><span class="comment">Loading all Java courses from Udemy .. </span></span><br><span class="line"><span class="comment">loading completed for Java courses </span></span><br><span class="line"><span class="comment">loading completed for development courses </span></span><br><span class="line"><span class="comment">all done.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Read more: http://www.java67.com/2018/04/java-countdownlatch-example-when-and-how.html#ixzz5GauJLPZA</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure><p>In this program, we have just three threads. One to download all <strong>Python courses</strong>, second to download all <strong>Java courses</strong> and the third one to download all Development courses.</p><p>I have created a CountDownLatch object with 3 counts as a static final variable:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch loadingLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>After that, we have three threads, which downloads data, in our case they don’t do anything just <a href="http://javarevisited.blogspot.sg/2011/12/difference-between-wait-sleep-yield.html#axzz5DmwFLA1K" target="_blank" rel="noopener">sleep</a> for 1, 2, and 3 seconds. </p><p>Every time a thread completes its execution it calls the <strong>countDown()</strong> method on the loadingLatch object. </p><p>The <code>main()</code> method keep checking for remaining counts using <code>getCount()</code> method and do whatever it wants to do only when the <strong>count reaches zero</strong>. Though I have used a while loop with <code>getCount()</code>, you can better use <code>latch.await()</code>method for waiting.</p><p>A picture is said to be worth a thousand words, so I tried to make this diagram to explain the concept to you. </p><p>In this diagram you can see that our main thread is waiting on <code>CoutnDownLatch</code> until all thread calls the countdown and count reaches zero, after that, it progressed further.  In short, the main thread was blocked waiting for other loader thread to finish their job.  </p><p>Btw, If you are not familiar with essential threading concepts e.g. wait, notify, sleep, blocking etc, I suggest you first go through <a href="https://click.linksynergy.com/fs-bin/click?id=JVFxdTr9V80&amp;subid=0&amp;offerid=323058.1&amp;type=10&amp;tmpid=14538&amp;RD_PARM1=https%3A%2F%2Fwww.udemy.com%2Fjava-the-complete-java-developer-course%2F" target="_blank" rel="noopener"><strong>Complete Java Masterclass</strong></a> to learn them.  </p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1frotpafqdoj30hs08r75u.jpg" alt="Java CountDownLatch Example - When and How to Use It"></p><h2><a href="#countdownlatch-important-points" class="header-anchor">#</a><span id="countdownlatch-important-points">CountDownLatch - Important Points</span></h2><p>Now that you know what is CountDownLatch in Java and how to use it for inter-thread communication and synchronization. It’s time to revise and remember some important points: </p><blockquote><ol><li>The CountDownLatch utility or class is only available on JRE 1.5 or later version. </li><li>You cannot reuse the latch once the count reaches zero. This is the main difference between a <a href="http://javarevisited.blogspot.sg/2012/07/cyclicbarrier-example-java-5-concurrency-tutorial.html#axzz5DmwFLA1K" target="_blank" rel="noopener">CyclicBarrier</a> and <a href="http://www.java67.com/2012/08/difference-between-countdownlatch-and-cyclicbarrier-java.html" target="_blank" rel="noopener">CountDownLatch</a>, which can be <strong>reused</strong>.</li><li>The getCount() method return the current count i.e. remaining threads which have not finished yet. </li><li>A thread can wait on latch by calling latch.await() method to start progress after remaining thread finishes their task.  </li><li>One of the simplest use of CountDownLatch class is to <strong>block a thread until other threads have finished their jobs</strong>.  </li></ol></blockquote><p>In our example, it was the main thread which was blocked by calling the await() method of CountDownLatch until all loader class finished their job i.e. downloaded courses from Udemy.   </p><p>That’s all about <strong>how to use CountDownLatch in Java</strong>. It’s a useful concurrency utility which can be used to keep track of completion of tasks done by multiple threads. If you are writing a Java application which loads data from another system before start functioning e.g. accepting client connections, you can use CountDownLatch to keep track of download tasks. </p><p><strong>Further Learning</strong></p><p> <a href="https://click.linksynergy.com/fs-bin/click?id=JVFxdTr9V80&amp;subid=0&amp;offerid=323058.1&amp;type=10&amp;tmpid=14538&amp;RD_PARM1=https%3A%2F%2Fwww.udemy.com%2Fjava-the-complete-java-developer-course%2F" target="_blank" rel="noopener">Complete Java Masterclass</a> </p><p><a href="https://click.linksynergy.com/fs-bin/click?id=JVFxdTr9V80&amp;subid=0&amp;offerid=323058.1&amp;type=10&amp;tmpid=14538&amp;RD_PARM1=https%3A%2F%2Fwww.udemy.com%2Fmultithreading-and-parallel-computing-in-java%2F" target="_blank" rel="noopener">Multithreading and Parallel Computing in Java</a> </p><p><a href="https://pluralsight.pxf.io/c/1193463/424552/7490?u=https%3A%2F%2Fwww.pluralsight.com%2Fcourses%2Fjava-patterns-concurrency-multi-threading" target="_blank" rel="noopener">Applying Concurrency and Multi-threading to Common Java Patterns</a> </p><p><a href="http://www.amazon.com/dp/0321349601/?tag=javamysqlanta-20" target="_blank" rel="noopener">Java Concurrency in Practice - The book</a> </p><p><a href="https://learning.javaspecialists.eu/courses/concurrency-in-practice-bundle?affcode=92815_johrd7r8" target="_blank" rel="noopener">Java Concurrency in Practice Course by Heinz Kabutz</a> </p><p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html" target="_blank" rel="noopener">CountDownLatch Java Documentation</a></p>]]></content>
    
    <summary type="html">
    
      Java多线程和并发实践-CountDownLatch用法
    
    </summary>
    
      <category term="hexo" scheme="http://blog.todolist.win/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://blog.todolist.win/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>常用hexo命令</title>
    <link href="http://blog.todolist.win/2017/07/08/hexocommand/"/>
    <id>http://blog.todolist.win/2017/07/08/hexocommand/</id>
    <published>2017-07-08T13:32:44.000Z</published>
    <updated>2017-07-08T15:25:15.000Z</updated>
    
    <content type="html"><![CDATA[<h5><a href="#hexo-an-zhuang-ming-ling" class="header-anchor">#</a><span id="hexo-an-zhuang-ming-ling">Hexo 安装命令</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g #安装  </span><br><span class="line">npm update hexo -g #升级  </span><br><span class="line">hexo init #初始化</span><br></pre></td></tr></table></figure><h5><a href="#chuang-jian-ming-ling" class="header-anchor">#</a><span id="chuang-jian-ming-ling">创建命令</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`hexo n "Article Title"` #n是new的简写</span><br><span class="line">`hexo p` #发布文章，同 hexo publish</span><br><span class="line">`hexo g` #生成静态内容，同hexo generate</span><br><span class="line">`hexo s` #启动本地预览服务，同hexo server</span><br><span class="line">`hexo d` #部署到远程服务，比如github等</span><br><span class="line">`hexo clean` #清楚缓存，一般很少用</span><br></pre></td></tr></table></figure><h5><a href="#server-ming-ling" class="header-anchor">#</a><span id="server-ming-ling">server命令</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`hexo server -s` #静态模式</span><br><span class="line">`hexo server -p 5000` #更改端口</span><br><span class="line">`hexo server -i 192.168.1.1` #更改ip</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5&gt;&lt;a href=&quot;#hexo-an-zhuang-ming-ling&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;span id=&quot;hexo-an-zhuang-ming-ling&quot;&gt;Hexo 安装命令&lt;/span&gt;&lt;/h5&gt;&lt;figure class=&quot;h
      
    
    </summary>
    
      <category term="Home" scheme="http://blog.todolist.win/categories/Home/"/>
    
      <category term="Hexo" scheme="http://blog.todolist.win/categories/Home/Hexo/"/>
    
    
      <category term="日记" scheme="http://blog.todolist.win/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>空-雨-伞</title>
    <link href="http://blog.todolist.win/2017/06/11/20170611-note/"/>
    <id>http://blog.todolist.win/2017/06/11/20170611-note/</id>
    <published>2017-06-11T09:03:11.000Z</published>
    <updated>2017-06-11T17:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在整理以前工作中的笔记时，遇到个麻烦事儿，到不是笔记不全，而是根本看不下去，一团糟，而且没有终点，导致百白花了精力。<br>先看看我整理的一些问题：</p><blockquote><ol><li>相同主题的笔记非常分散</li><li>全篇无重点</li><li>笔记当时没有精简提炼，导致再整理时已经忘记当时的内容</li><li>没有适当的使用画图的方式加深理解</li><li>页面太小，所有内容挤在一堆</li></ol></blockquote><p>要不是这个问题困扰我许久，获取到现在还没有发现，原来之前的笔记就是个摆设，或者说我会继续这种乱糟糟的笔记方式……<br>于是抱着解决这个困扰我许久的问题想法，找了很多相关的笔记法，想以此为契机，整理一系列各种笔记法的文章，以此找到更适合自己的方式，每篇文章最后都会附上个人的实践结论，仅供参考……<br><a id="more"></a></p><h3><a href="#shi-me-shi-kong-yu-san-bi-ji-fa" class="header-anchor">#</a><span id="shi-me-shi-kong-yu-san-bi-ji-fa">什么是空-雨-伞笔记法</span></h3><p><img src="/2017/06/11/20170611-note/001.jpg" alt=""><br>“在麦肯锡，所有思考都需严格按照‘空•雨•伞’三步执行” —- 《从麦肯锡到企业家》一书作者</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在整理以前工作中的笔记时，遇到个麻烦事儿，到不是笔记不全，而是根本看不下去，一团糟，而且没有终点，导致百白花了精力。&lt;br&gt;先看看我整理的一些问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;相同主题的笔记非常分散&lt;/li&gt;
&lt;li&gt;全篇无重点&lt;/li&gt;
&lt;li&gt;笔记当时没有精简提炼，导致再整理时已经忘记当时的内容&lt;/li&gt;
&lt;li&gt;没有适当的使用画图的方式加深理解&lt;/li&gt;
&lt;li&gt;页面太小，所有内容挤在一堆&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;要不是这个问题困扰我许久，获取到现在还没有发现，原来之前的笔记就是个摆设，或者说我会继续这种乱糟糟的笔记方式……&lt;br&gt;于是抱着解决这个困扰我许久的问题想法，找了很多相关的笔记法，想以此为契机，整理一系列各种笔记法的文章，以此找到更适合自己的方式，每篇文章最后都会附上个人的实践结论，仅供参考……&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Home" scheme="http://blog.todolist.win/categories/Home/"/>
    
      <category term="笔记法" scheme="http://blog.todolist.win/categories/Home/%E7%AC%94%E8%AE%B0%E6%B3%95/"/>
    
    
      <category term="日记" scheme="http://blog.todolist.win/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>一些关于架构的</title>
    <link href="http://blog.todolist.win/2017/06/10/20170610-note-architecture/"/>
    <id>http://blog.todolist.win/2017/06/10/20170610-note-architecture/</id>
    <published>2017-06-10T14:58:39.000Z</published>
    <updated>2017-06-11T09:19:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3><a href="#guan-yu-jia-gou-zhuan" class="header-anchor">#</a><span id="guan-yu-jia-gou-zhuan">关于架构[转]</span></h3><hr><p><a href="http://www.infoq.com/cn/articles/every-architect-should-study-conway-law/" target="_blank" rel="noopener">原文地址</a> </p><h4><a href="#jia-gou-de-ding-yi-yu-li-jie" class="header-anchor">#</a><span id="jia-gou-de-ding-yi-yu-li-jie">架构的定义与理解</span></h4><p>一. 架构系统前, 架构师的首要任务是 尽最快可能找到利益相关者: <code>业务方</code>, <code>产品经理</code>, <code>客户/用户</code>, <code>开发经理</code>, <code>工程师</code>, <code>项目经理</code>,  <code>测试人员</code> , <code>运维人员</code> ,<code>产品运营人员</code> 等等都可能是利益相关者, 架构师要充分和利益相关者沟通, 深入了解他们的关注点和痛点, 并找出并构架出这些关注点的解决方案.</p><p>二. 利益相关者的关注点是有可能冲突的, 比如: </p><blockquote><ol><li>管理者(可管理性) VS 技术方 (性能)</li><li>业务方(多快好省) VS 技术方(可靠稳定)   </li></ol></blockquote><p>等等这些需要架构师去灵活的平衡, 如何平衡体现了架构师的水平</p><p>三. 架构主要关注非功能性需求 </p><blockquote><ol><li>易于分解(保持独立性)</li><li>易于理解</li><li>易于扩展</li><li>易于变更</li><li>易于替换</li><li>易于部署</li><li>易于伸缩(伸缩性)</li><li>易于恢复(还原能力)</li><li>易于连接(统一接口)</li><li>易于交付(成本&amp;效率)</li></ol></blockquote><p>四. 架构的目的用于管理复杂性、易变性和不确定性， 确保长期演变的架构部分的变化不会对架构的其他部分产生不必要的负面影响. 这样可以确保业务和开发的敏捷， 让应用的易变部分能够频繁的变化而不影响（或者影响更少）应用其他部分  </p><p>五. 国内企业IT的现状是：无数高耦合的遗留系统，不良的架构设计导致限制了企业的业务，升级替换的成本巨大，<u>所以此时架构的关注点由性能、高可用转变为更加关注可维护性、可扩展性、成本</u>。 所以企业创业之初选择好的架构师或技术负责人非常重要.<br>……<br><a id="more"></a> </p><h4><a href="#jia-gou-de-die-dai-he-yan-hua-xing" class="header-anchor">#</a><span id="jia-gou-de-die-dai-he-yan-hua-xing">架构的迭代和演化性</span></h4><h5><a href="#yi-rup-de-san-ge-te-dian" class="header-anchor">#</a><span id="yi-rup-de-san-ge-te-dian">一. RUP的三个特点</span></h5><blockquote><ol><li>用例和风险驱动(use case and risk driven)</li><li>架构中心(Architecture centric)</li><li>迭代和增量(Iterative and incremental) </li></ol></blockquote><p>RUP提倡以架构和风险驱动, 项目一开始要做到 端到端的原型(prototype) ； 通过压力测试验证框架的可行性 ，在原型的基础上进行持续迭代和增量开发， 开发-&gt;测试-&gt;调整架构-&gt;开发</p><p><img src="/2017/06/10/20170610-note-architecture/114.jpg" alt=""></p><p>从上面的图可以看出：<code>架构是一个不断演进和迭代的过程</code> 而不是一蹴而就 ，一来就求大而全（架构师的完美主义不一定是好事），所以架构师要尽量写代码，做测试，否则纸上谈兵然后丢给开发团队是很不负责任的做法，容易造成产品不能满足最终用户需求。</p><h5><a href="#er-zui-xiao-ke-yong-chan-pin" class="header-anchor">#</a><span id="er-zui-xiao-ke-yong-chan-pin">二. 最小可用产品</span></h5><p>最小可用产品（Minimum Viable Product， MVP）理念, 即迅速做出最小可用的产品，丢给客户试用，快速获取用户反馈，在此基础上不断进行产品架构的迭代和演化升级: </p><p><img src="/2017/06/10/20170610-note-architecture/115.jpg" alt=""></p><p>如上图就是描述了架构师应该迅速做出最小可用产品，从而使得用户尽快试用产品并在此基础上快速更新升级，否则做出最终的产品无法满足客户需求而导致了成本和风险的提高。</p><p><img src="/2017/06/10/20170610-note-architecture/116.jpg" alt=""></p><p>上图反应了过度工程(Over Engineering)的问题, 其实就是产品架构和用户之间没有形成有效的反馈闭环</p><blockquote class="blockquote-center"><br><br><strong> 注意 </strong> ，在系统真正地投入生产使用之前，再好的架构都只是假设，产品越晚被使用者使用，失败的成本和风险就越高，而小步行进，通过 <strong><strong> MVP </strong></strong> 快速实验，获取客户反馈，迭代演化产品，能有效地减少失败的成本和风险。<br><br></blockquote><h5><a href="#can-kao-zi-liao" class="header-anchor">#</a><span id="can-kao-zi-liao">参考资料</span></h5><ul><li><a href="http://itrevolution.com/the-three-ways-principles-underpinning-devops/" target="_blank" rel="noopener">THE THREE WAYS: THE PRINCIPLES UNDERPINNING DEVOPS</a></li><li><a href="http://baike.baidu.com/link?url=PcIm9RTOWnAd0rqN7f5rrlbt9QmjWgPctJ5i4K5ObjPqD7KtOMIQRBiUVMZ5YpuQ_uymtAdsT-n-0hB4sCVyNK" target="_blank" rel="noopener">统一软件开发过程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关于架构-转&quot;&gt;&lt;a href=&quot;#关于架构-转&quot; class=&quot;headerlink&quot; title=&quot;关于架构[转]&quot;&gt;&lt;/a&gt;关于架构[转]&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/every-architect-should-study-conway-law/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt; &lt;/p&gt;
&lt;h4 id=&quot;架构的定义与理解&quot;&gt;&lt;a href=&quot;#架构的定义与理解&quot; class=&quot;headerlink&quot; title=&quot;架构的定义与理解&quot;&gt;&lt;/a&gt;架构的定义与理解&lt;/h4&gt;&lt;p&gt;一. 架构系统前, 架构师的首要任务是 尽最快可能找到利益相关者: &lt;code&gt;业务方&lt;/code&gt;, &lt;code&gt;产品经理&lt;/code&gt;, &lt;code&gt;客户/用户&lt;/code&gt;, &lt;code&gt;开发经理&lt;/code&gt;, &lt;code&gt;工程师&lt;/code&gt;, &lt;code&gt;项目经理&lt;/code&gt;,  &lt;code&gt;测试人员&lt;/code&gt; , &lt;code&gt;运维人员&lt;/code&gt; ,&lt;code&gt;产品运营人员&lt;/code&gt; 等等都可能是利益相关者, 架构师要充分和利益相关者沟通, 深入了解他们的关注点和痛点, 并找出并构架出这些关注点的解决方案.&lt;/p&gt;
&lt;p&gt;二. 利益相关者的关注点是有可能冲突的, 比如: &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;管理者(可管理性) VS 技术方 (性能)&lt;/li&gt;
&lt;li&gt;业务方(多快好省) VS 技术方(可靠稳定)   &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;等等这些需要架构师去灵活的平衡, 如何平衡体现了架构师的水平&lt;/p&gt;
&lt;p&gt;三. 架构主要关注非功能性需求 &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;易于分解(保持独立性)&lt;/li&gt;
&lt;li&gt;易于理解&lt;/li&gt;
&lt;li&gt;易于扩展&lt;/li&gt;
&lt;li&gt;易于变更&lt;/li&gt;
&lt;li&gt;易于替换&lt;/li&gt;
&lt;li&gt;易于部署&lt;/li&gt;
&lt;li&gt;易于伸缩(伸缩性)&lt;/li&gt;
&lt;li&gt;易于恢复(还原能力)&lt;/li&gt;
&lt;li&gt;易于连接(统一接口)&lt;/li&gt;
&lt;li&gt;易于交付(成本&amp;amp;效率)&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;四. 架构的目的用于管理复杂性、易变性和不确定性， 确保长期演变的架构部分的变化不会对架构的其他部分产生不必要的负面影响. 这样可以确保业务和开发的敏捷， 让应用的易变部分能够频繁的变化而不影响（或者影响更少）应用其他部分  &lt;/p&gt;
&lt;p&gt;五. 国内企业IT的现状是：无数高耦合的遗留系统，不良的架构设计导致限制了企业的业务，升级替换的成本巨大，&lt;u&gt;所以此时架构的关注点由性能、高可用转变为更加关注可维护性、可扩展性、成本&lt;/u&gt;。 所以企业创业之初选择好的架构师或技术负责人非常重要.&lt;br&gt;……&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Home" scheme="http://blog.todolist.win/categories/Home/"/>
    
    
      <category term="日记" scheme="http://blog.todolist.win/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>札记</title>
    <link href="http://blog.todolist.win/2017/06/09/%E6%9C%AD%E8%AE%B0/"/>
    <id>http://blog.todolist.win/2017/06/09/札记/</id>
    <published>2017-06-09T06:21:11.000Z</published>
    <updated>2017-06-09T06:21:11.000Z</updated>
    
    <summary type="html">
    
      一些札记
    
    </summary>
    
      <category term="Home" scheme="http://blog.todolist.win/categories/Home/"/>
    
    
      <category term="日记" scheme="http://blog.todolist.win/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>基于Nginx的最简单的负载均衡</title>
    <link href="http://blog.todolist.win/2017/06/09/nginx/"/>
    <id>http://blog.todolist.win/2017/06/09/nginx/</id>
    <published>2017-06-09T03:44:52.000Z</published>
    <updated>2017-06-13T10:56:18.000Z</updated>
    
    <content type="html"><![CDATA[<h5><a href="#cha-kan-linux-shang-duan-kou-de-zhan-yong-qing-kuang" class="header-anchor">#</a><span id="cha-kan-linux-shang-duan-kou-de-zhan-yong-qing-kuang">查看linux上端口的占用情况</span></h5><blockquote><p>单机多端口应用做负载均衡部署时，选择tomcat配置不同端口</p><p>使用lsof 命令配合-i参数，即可查看指定端口的占用情况<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost webapps]# lsof -i:8082</span><br><span class="line">COMMAND   PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME</span><br><span class="line">java    29756 root   50u  IPv6 6161829      0t0  TCP *:us-cli (LISTEN)</span><br></pre></td></tr></table></figure></p></blockquote><h5><a href="#ji-yu-openresty-de-nginx-zuo-fu-zai-jun-heng-pei-zhi" class="header-anchor">#</a><span id="ji-yu-openresty-de-nginx-zuo-fu-zai-jun-heng-pei-zhi">基于Openresty的nginx做负载均衡配置</span></h5><p>说是基于Openresty，其实这里主要还是用nginx做负载,至于Openresty的使用，后面专题再讲  </p><p>nginx要做下面几个配置:  </p><ul><li>upstream配置</li><li>nginx.conf配置</li></ul><ol><li>upstream配置如下:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream wxshop &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 127.0.0.1:8089 weight=1 max_fails=3 fail_timeout=10s;</span><br><span class="line">    server 127.0.0.1:8082 weight=1 max_fails=3 fail_timeout=10s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>关于upstream更详细的用法，参考另一篇博客 <a href="">Nginx模块之-upstream</a>  </p></blockquote><p>PS:<br>部分参数说明:  </p><blockquote><p><strong>ip_hash</strong> 用于通知nginx使用ip hash负载均衡算法,<br>如果没加这条指令，nginx会使用默认的round robin负载均衡模块<br><strong>weight</strong> 访问权重,默认1，值越大，权重越大<br><strong>max_fails</strong> 允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误<br><strong>fail_timeout</strong> ==max_fails== 次失败后，暂停的时间<br><strong>down</strong> 表示单前的server暂时不参与负载<br><strong>backup</strong> 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻  </p></blockquote><ol start="2"><li>nginx.conf配置如下  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">location /shop &#123;</span><br><span class="line">                proxy_pass http://wxshop;</span><br><span class="line">                proxy_redirect off;</span><br><span class="line">                proxy_set_header Host $host;</span><br><span class="line">                proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">                #client_max_body_size 20m;</span><br><span class="line">                #client_body_buffer_size 128k;</span><br><span class="line">                #proxy_connect_timeout 600;</span><br><span class="line">                #proxy_send_timeout 600;</span><br><span class="line">                #proxy_read_timeout 900;</span><br><span class="line">                #proxy_buffer_size 4k;</span><br><span class="line">                #proxy_buffers 4 32k;</span><br><span class="line">                #proxy_busy_buffers_size 64k;</span><br><span class="line">                #proxy_temp_file_write_size 64k;</span><br><span class="line">        &#125;</span><br><span class="line">        location /shop2 &#123;</span><br><span class="line">                proxy_pass http://192.168.8.118:8089/shop;</span><br><span class="line">                proxy_redirect off;</span><br><span class="line">                proxy_set_header Host $host;</span><br><span class="line">                root html;</span><br><span class="line">                index index.html index.jsp index.htm;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        location /shop3/ &#123;</span><br><span class="line">                proxy_pass http://192.168.8.118:8082/shop;</span><br><span class="line">                proxy_redirect off;</span><br><span class="line">                proxy_set_header Host $host;</span><br><span class="line">                root html;</span><br><span class="line">                index index.html index.jsp index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        location /wxpay3 &#123;</span><br><span class="line">                proxy_pass http://192.168.8.118:8082/wxpay;</span><br><span class="line">                proxy_redirect off;</span><br><span class="line">                proxy_set_header Host $host;</span><br><span class="line">                root html;</span><br><span class="line">                index index.html index.jsp index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        location /wxpay &#123;</span><br><span class="line">                proxy_pass http://192.168.8.118:8089/wxpay;</span><br><span class="line">                proxy_redirect off;</span><br><span class="line">                proxy_set_header Host $host;</span><br><span class="line">                root html;</span><br><span class="line">                index index.html index.jsp index.htm;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol><h5><a href="#session-gong-xiang" class="header-anchor">#</a><span id="session-gong-xiang">session共享</span></h5><p>session共享问题是负载均衡部署很重要的问题，如果是一个用户的请求始终分配到其中一台服务器上，就不存在session共享的问题，如果是一个用户的请求可能被分配到多台服务器时，就存在session共享问题了，<br>我们的系统中主要是采用了spring redis的结合，将整个web端的会话存储到redis中，从而实现了session共享</p><p>未完待续……</p><h5><a href="#can-kao-wen-dang" class="header-anchor">#</a><span id="can-kao-wen-dang">参考文档</span></h5><ul><li><a href="http://tengine.taobao.org/book/chapter_05.html" target="_blank" rel="noopener">Nginx模块开发篇</a></li><li><a href="http://debugo.com/nginx-web-upstream/" target="_blank" rel="noopener">Nginx基本服务与upstream配置详解</a>  </li><li><a href="http://blog.csdn.net/andong154564667/article/details/52121765" target="_blank" rel="noopener">实现nginx的负载均衡</a></li><li><a href="http://www.cnblogs.com/mecity/archive/2011/06/20/2085529.html" target="_blank" rel="noopener">Nginx的负载均衡的那点事</a></li><li>[<a href="https://github.com/ewolff/microservice]" target="_blank" rel="noopener">https://github.com/ewolff/microservice]</a></li></ul>]]></content>
    
    <summary type="html">
    
      一些札记
    
    </summary>
    
      <category term="Home" scheme="http://blog.todolist.win/categories/Home/"/>
    
    
      <category term="日记" scheme="http://blog.todolist.win/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM性能分析之Dump文件生成与分析</title>
    <link href="http://blog.todolist.win/2017/01/17/JVM%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8BDump%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>http://blog.todolist.win/2017/01/17/JVM性能分析之Dump文件生成与分析/</id>
    <published>2017-01-17T06:56:54.000Z</published>
    <updated>2017-01-17T07:18:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3><a href="#dump-ji-ben-gai-nian" class="header-anchor">#</a><span id="dump-ji-ben-gai-nian">Dump基本概念</span></h3><p>常用dump文件分为: heap dump和 thread dump两种，heap dump主要记录了内存信息，thread dump 记录了CPU信息 </p><p><strong><code>heap dump</code></strong> 文件是一个二进制文件，它保存了某一时刻JVM堆中对象使用情况。HeapDump文件是指定时刻的Java堆栈的快照，是一种镜像文件。Heap Analyzer工具通过分析HeapDump文件，哪些对象占用了太多的堆栈空间，来发现导致内存泄露或者可能引起内存泄露的对象。</p><p><strong><code>thread dump</code></strong> 文件主要保存的是java应用中各线程在某一时刻的运行的位置，即执行到哪一个类的哪一个方法哪一个行上。thread dump是一个文本文件，打开后可以看到每一个线程的执行栈，以stacktrace的方式显示。通过对thread dump的分析可以得到应用是否“卡”在某一点上，即在某一点运行的时间太长，如数据库查询，长期得不到响应，最终导致系统崩溃。单个的thread dump文件一般来说是没有什么用处的，因为它只是记录了某一个绝对时间点的情况。比较有用的是，线程在一个时间段内的执行情况。<br>两个thread dump文件在分析时特别有效，困为它可以看出在先后两个时间点上，线程执行的位置，如果发现先后两组数据中同一线程都执行在同一位置，则说明此处可能有问题，因为程序运行是极快的，如果两次均在某一点上，说明这一点的耗时是很大的。通过对这两个文件进行分析，查出原因，进而解决问题。</p><p>这两个文件可以使用jdk自带的工具生成. . </p><h4><a href="#heap-dump" class="header-anchor">#</a><span id="heap-dump">heap dump</span></h4><p>使用 jdk的jmap命令<br><code>jmap -dump:format=b,file=heap.hprof 2576</code> </p><p>如果我们只需要将dump中存活的对象导出，那么可以使用:live参数 </p><p><code>jmap -dump:live,format=b,file=heapLive.hprof 2576</code>  </p><h4><a href="#thread-dump" class="header-anchor">#</a><span id="thread-dump">thread dump</span></h4><p>使用 <code>jstack 2576 &gt; thread.txt</code>  </p><p>有了dump文件后，再结合使用性能分析工具就可以获取并分析文件中的系统信息  </p><h3><a href="#shi-yong-gong-ju-fen-xi-heap-dump-wen-jian" class="header-anchor">#</a><span id="shi-yong-gong-ju-fen-xi-heap-dump-wen-jian">使用工具分析heap dump文件</span></h3><h4><a href="#jhat-ming-ling" class="header-anchor">#</a><span id="jhat-ming-ling">jhat命令</span></h4><h4><a href="#eclipse-mat" class="header-anchor">#</a><span id="eclipse-mat">eclipse MAT</span></h4>]]></content>
    
    <summary type="html">
    
      dump文件记录了JVM在运行期间的内存占用、线程执行等情况，利用dump文件结合eclipse MAT工具可以有效的排查项目运行中的性能及内存等问题
    
    </summary>
    
    
      <category term="jvm" scheme="http://blog.todolist.win/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>使用Git管理项目</title>
    <link href="http://blog.todolist.win/2017/01/17/%E4%BD%BF%E7%94%A8Git%E7%AE%A1%E7%90%86%E9%A1%B9/"/>
    <id>http://blog.todolist.win/2017/01/17/使用Git管理项/</id>
    <published>2017-01-17T03:25:16.000Z</published>
    <updated>2017-01-17T03:44:34.000Z</updated>
    
    <summary type="html">
    
      作为源码版本控制技术栈的一部分，Git是一个重要的工具，由于工作上的原因一直都没有使用到Git,但是对于热衷各种开源项目的我，已经看到了越来越多的项目使用了Git，似乎使用Git已经是一个标准配套
    
    </summary>
    
      <category term="Git" scheme="http://blog.todolist.win/categories/Git/"/>
    
    
      <category term="Git" scheme="http://blog.todolist.win/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>OpenSource</title>
    <link href="http://blog.todolist.win/2017/01/10/OpenSource/"/>
    <id>http://blog.todolist.win/2017/01/10/OpenSource/</id>
    <published>2017-01-10T01:36:12.000Z</published>
    <updated>2017-01-10T02:42:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3><a href="#zipkin" class="header-anchor">#</a><span id="zipkin">zipkin</span></h3><p>用于分布式微服务系统的服务追踪 </p><blockquote class="blockquote-center"><br>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in microservice architectures<br></blockquote><p><a href="https://github.com/openzipkin/zipkin" target="_blank" rel="noopener">https://github.com/openzipkin/zipkin</a></p>]]></content>
    
    <summary type="html">
    
      从GitHub上收集一些有意思的开源项目，
    
    </summary>
    
      <category term="OpenSource" scheme="http://blog.todolist.win/categories/OpenSource/"/>
    
    
      <category term="Github" scheme="http://blog.todolist.win/tags/Github/"/>
    
      <category term="OpenSource" scheme="http://blog.todolist.win/tags/OpenSource/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 集成目录插件</title>
    <link href="http://blog.todolist.win/2017/01/09/Hexo-%E9%9B%86%E6%88%90%E7%9B%AE%E5%BD%95%E6%8F%92%E4%BB%B6/"/>
    <id>http://blog.todolist.win/2017/01/09/Hexo-集成目录插件/</id>
    <published>2017-01-09T12:37:52.000Z</published>
    <updated>2017-01-10T02:13:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>hexo提供了丰富的<a href="https://hexo.io/plugins/" target="_blank" rel="noopener">插件列表</a></p><p>好的博客文章应该具备清晰的层级结构，hexo默认没有不支持目录的生成（或者支持，我没有找到方法？，总之我找到一个新的通过集成hexo插件的方式）,今天主要是集成一下hexo主题对应的目录插件</p><p>我们选择<a href="https://github.com/bubkoo/hexo-toc" target="_blank" rel="noopener">hexo-toc</a></p><a id="more"></a><h3><a href="#an-zhuang-hexo-toc" class="header-anchor">#</a><span id="an-zhuang-hexo-toc">安装hexo-toc</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-toc --save</span><br></pre></td></tr></table></figure><p>安装完成后，在站点配置文件(_config.xml)文件中添加如下配置选项</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line"><span class="attr">  maxdepth:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  class:</span> <span class="string">toc</span></span><br><span class="line"><span class="attr">  slugify:</span> <span class="string">transliteration</span></span><br><span class="line"><span class="attr">  anchor:</span></span><br><span class="line"><span class="attr">    position:</span> <span class="string">after</span></span><br><span class="line"><span class="attr">    symbol:</span> <span class="string">'#'</span></span><br><span class="line"><span class="attr">    style:</span> <span class="string">header-anchor</span></span><br></pre></td></tr></table></figure><blockquote><p><code>maxdepth</code>表示支持的层级深度，即 <code>symbol</code>指定的分隔符的长度</p><p><code>class</code> 表示toc生成的样式Class</p><p><code>slugify</code>: Choose which slugify function you want to use. Currently support <a href="https://github.com/jeremys/uslug" target="_blank" rel="noopener">uslug</a> (<em>Default</em>) and <a href="https://github.com/andyhu/node-transliteration" target="_blank" rel="noopener">transliteration</a>.(slugify功能目前不知道什么用途，暂时用的)</p></blockquote>]]></content>
    
    <summary type="html">
    
      好的博客文章应该具备清晰的层级结构, 一眼就能看出作者的思路脉络, 今天就来看看hexo如何集成toc目录插件
    
    </summary>
    
      <category term="hexo" scheme="http://blog.todolist.win/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://blog.todolist.win/tags/hexo/"/>
    
      <category term="Github" scheme="http://blog.todolist.win/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 安装笔记</title>
    <link href="http://blog.todolist.win/2017/01/09/Hexo-%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.todolist.win/2017/01/09/Hexo-安装笔记/</id>
    <published>2017-01-09T06:32:33.000Z</published>
    <updated>2017-06-08T11:47:57.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#hexo-an-zhuang-bi-ji">Hexo 安装笔记</a><ul><li><a href="#1-jian-yao-shuo-ming">1.简要说明</a></li><li><a href="#2-hexo-chang-yong-ming-ling">2. Hexo常用命令</a></li><li><a href="#ru-he-bu-shu-dao-github-shang">如何部署到GitHub上</a></li></ul></li></ul><!-- tocstop --></div><h3><a href="#hexo-an-zhuang-bi-ji" class="header-anchor">#</a><span id="hexo-an-zhuang-bi-ji">Hexo 安装笔记</span></h3><h4><a href="#1-jian-yao-shuo-ming" class="header-anchor">#</a><span id="1-jian-yao-shuo-ming">1.简要说明</span></h4><p><a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io/</a><br>使用npm安装命令如下</p><blockquote><p>npm install hexo-cli -g<br>hexo init blog<br>cd blog<br>npm install<br>hexo server</p></blockquote><p>npm在国内访问较慢，可以使用阿里的镜像地址，使用如下命令切换<br><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code><br>后续命令npm命令使用 cnpm代替</p><h4><a href="#2-hexo-chang-yong-ming-ling" class="header-anchor">#</a><span id="2-hexo-chang-yong-ming-ling">2. Hexo常用命令</span></h4><h5><a href="#init" class="header-anchor">#</a><span id="init">init</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo init [folder]</span><br></pre></td></tr></table></figure><p>初始化一个新的网站目录,如果不指定则默认使用当前目录</p><h5><a href="#new" class="header-anchor">#</a><span id="new">new</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>创建一篇新的文章，使用layout指定的布局方式，如果layout不指定，则使用<code>_config.yml</code> 中的<code>default_layout</code>  指定的值, title为文章标题，如果title中含有空格，需要使用双引号包含整个title</p><h5><a href="#generate" class="header-anchor">#</a><span id="generate">generate</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>创建静态文件,有如下参数</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-w, –watch</td><td>Watch file changes</td></tr><tr><td>-d, –deploy</td><td>Deploy after generation finishes</td></tr></tbody></table><h5><a href="#publish" class="header-anchor">#</a><span id="publish">publish</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>发布一条草稿</p><h5><a href="#server" class="header-anchor">#</a><span id="server">server</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo server</span><br></pre></td></tr></table></figure><p>启动本地服务: 默认访问地址是 <code>http://localhost:4000/</code></p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-p, –port</td><td>Override default port</td></tr><tr><td>-s, –static</td><td>Only serve static files</td></tr><tr><td>-l, –log</td><td>Enable logger. Override logger format.</td></tr></tbody></table><h5><a href="#deploy" class="header-anchor">#</a><span id="deploy">deploy</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo deploy</span><br></pre></td></tr></table></figure><p>部署网站</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-g, –generate</td><td>在部署前创建</td></tr></tbody></table><h5><a href="#render" class="header-anchor">#</a><span id="render">render</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure><p>渲染文件</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-o, –output</td><td>输出到指定目录</td></tr></tbody></table><h5><a href="#migrate" class="header-anchor">#</a><span id="migrate">migrate</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo migrate &lt;type&gt;</span><br></pre></td></tr></table></figure><p>从其他博客系统迁移内容</p><h5><a href="#clean" class="header-anchor">#</a><span id="clean">clean</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo clean</span><br></pre></td></tr></table></figure><p>清理缓存文件<code>(db.json)</code> 然后重新创建文件目录 <code>(public)</code>.</p><h5><a href="#list" class="header-anchor">#</a><span id="list">list</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure><p>列举网站(博客)信息List the information of the site.<br>type可选的值列表 : page, post, route, tag, category</p><h4><a href="#ru-he-bu-shu-dao-github-shang" class="header-anchor">#</a><span id="ru-he-bu-shu-dao-github-shang">如何部署到GitHub上</span></h4><p>关于如何开启GitHub的Pages服务,网上的资料太多,而且大同小异, 这里就不在重复.</p><blockquote><p>编辑完文章后 使用 <code>hexo d -g</code> 即可部署到GitHub上</p></blockquote><p>未完待续……</p><hr><p>参考引用:   </p><ul><li><a href="http://blog.csdn.net/jzooo/article/details/46781805" target="_blank" rel="noopener">http://blog.csdn.net/jzooo/article/details/46781805</a>  </li><li><a href="http://baixin.io/2016/06/HEXO_Advanced/" target="_blank" rel="noopener">http://baixin.io/2016/06/HEXO_Advanced/</a>  </li><li><a href="http://www.jianshu.com/p/465830080ea9" target="_blank" rel="noopener">http://www.jianshu.com/p/465830080ea9</a></li></ul>]]></content>
    
    <summary type="html">
    
      终于开始了2017年的第一篇博客了，想想没说好说的，要不就从搭建一个github网站开始吧，这里我用的是Hexo静态博客，使用Github的Pages服务并绑定个人域名http://blog.todolist.win
    
    </summary>
    
      <category term="hexo" scheme="http://blog.todolist.win/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://blog.todolist.win/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Vue实例</title>
    <link href="http://blog.todolist.win/2017/01/08/Vue%E5%AE%9E%E4%BE%8B/"/>
    <id>http://blog.todolist.win/2017/01/08/Vue实例/</id>
    <published>2017-01-08T07:40:11.000Z</published>
    <updated>2017-06-09T06:47:35.000Z</updated>
    
    <content type="html"><![CDATA[<h4><a href="#vue-shi-li-sheng-ming-zhou-qi" class="header-anchor">#</a><span id="vue-shi-li-sheng-ming-zhou-qi">Vue实例生命周期</span></h4><p>每个Vue实例被创建之前要经过一系列的初始化过程，</p><p>实例需要配置:</p><blockquote><p>1.配置数据观测(Data Observer)<br>2.编译模板<br>3.挂载实例到DOM<br>4.数据变化时更新DOM</p></blockquote><p>在上述过程中，实例会调用生命周期的一些钩子方法,可以执行自定义逻辑：</p><blockquote><p>created: 钩子方法, 在实例被创建之后被调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">data: &#123;</span><br><span class="line">a: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//`this` 指向vm实例</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a is: '</span> + <span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p></blockquote><p>还有其他钩子，例如 <code>mounted</code>, <code>updated</code>, <code>destroyed</code>, 这些钩子可以再实例生命周期的不同阶段调用，<code>this</code>关键字指向的是vue的实例.<br>vue中无控制器的概念，需要自定义逻辑，可以分别在这些不同的钩子方法中实现</p><p><img src="/2017/01/08/Vue实例/lifecycle.png" alt="生命周期"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4&gt;&lt;a href=&quot;#vue-shi-li-sheng-ming-zhou-qi&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;span id=&quot;vue-shi-li-sheng-ming-zhou-qi&quot;&gt;Vue实例生命周期&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;每个V
      
    
    </summary>
    
    
  </entry>
  
</feed>
